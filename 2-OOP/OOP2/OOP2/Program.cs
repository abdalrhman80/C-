using OOP02;
using OOP2.Inheritance;
using OOP2.Polymorphism.Method_Overriding;

namespace OOP2
{
    internal class Program
    {
        #region Method Overloading
        public static int Sum(int X, int Y)
        {
            return X + Y;
        }
        public static int Sum(int X, int Y, int Z)
        {
            return X + Y + Z;
        }
        public static float Sum(int X, int Y, int Z, float W)
        {
            return X + Y + Z + W;
        }
        public static double Sum(int X, double Y)
        {
            return X + Y;
        }
        public static double Sum(double X, int Y)
        {
            return X + Y;
        }
        #endregion

        static void Main(string[] args)
        {

            #region 1 Class Vs Struct

            #region Class
            /*
             * Type: Reference Types.
             * OOP Principles: Support All OOP Principles .
             * Access Modifiers: Allowed 6 Access Modifiers Inside It.
             * Constructors: If You Defined a user defined Constructor, Compiler Will Stop Generate 
                             Empty Parameterless Constructor.

             * Memory Allocation:
                 * References are stored on the Stack.
                 * Objects are allocated on the Heap.
                 * When the Main method execution ends, Stack Frames are cleared and removing the references. 
                   However, the objects remain on the Heap until garbage collected, this Leads to Stop The Project for seconds.

             * Use Cases: Suitable for large, complex objects that may require inheritance and polymorphic behavior.
            */
            #endregion

            #region Struct
            /*
             * Type: Value Types.
             
             * OOP Principles: Support Only Encapsulation, and Polymorphism (Overloading).
             
             * Access Modifiers: Allowed 3 Access Modifiers Inside It (Public - Privet - Internal).
             
             * Constructors: Always have a parameterless constructor generated by the compiler, 
                             even if user-defined constructors are provided.
            
             * Memory Allocation: When a Main method execution ends, the stack frame is cleared and removing the structs.
             
             * Use Cases: Suitable for small, lightweight objects that do not require inheritance.
            */
            #endregion

            #endregion

            #region 2 Constructor Channing
            /*
             * The Main Concept Of Inheritance.
             
             * The process of calling one constructor from another constructor
               within the same class [:this()] or from the base class [:base()].
             
             * This process done to avoid duplicate codes while having constructor overloading
               and to ensure that initialization is done consistently.
            */

            //Car c3 = new Car(5);
            //Console.WriteLine(c3);

            //Console.WriteLine("--------------------------------------");

            //Car c2 = new Car(10, "BMW");
            //Console.WriteLine(c2);

            //Console.WriteLine("--------------------------------------");

            //Car c1 = new Car(15, "Honda", 100);
            //Console.WriteLine(c1);

            #endregion

            #region 3 Inheritance
            /*
             * Inheritance allows us to create a new class from an existing class.
             
             * The class being inherited from => Base Class (Parent).
               The class that inherits from another class => Derived Class (Child).

             * The derived class inherits the fields and methods of the base class.
            
             * The class can inherit from only one class.
             
             * To inherit from a class, use the [:] symbol = > [Child : Parent]
             
             * The Constructor Of Child Class Should Do (Constructor Channing) With Constructor Of Base Class [:base()].
             
             * Inheritance is an [is-a] relationship.
                * We use inheritance only if there is an [is-a] relationship between two classes.
                * Apple is a Fruit, Car is a Vehicle, Dog is an Animal.
            */

            //Child Ch1 = new Child(3, 4, 4);
            //Console.WriteLine(Ch1);
            #endregion

            #region 4 Access Modifiers (Protected- Private Protected- Internal Protected)
            /*
             * 1. Protected
                  * When we declare a type member as protected, it can only be accessed from the same class 
                    and its derived classes.
             
             * 2. Private Protected 
                 * When we declare a member private protected, it can only be accessed within the same class,
                   and its derived class within the (same project).
             
             * 3. Internal Protected
                 * When we declare a member protected internal, it can be accessed from the same project, 
                   and the derived class of the containing class from any (other project).
            */
            #endregion

            #region 5 Association vs Aggregation vs Composition 
            /*
             * Association is another type of relation between classes.
             * Association is (has-a) relationship.
             * Association can be of various types, such as one-to-one, one-to-many, many-to-one, and many-to-many.
             * Two Types of Association :
                 * Composition [Mandatory]
                 * Aggregation [optional]
             
             * Order has an Item [Composition], Departments has a Employees [Aggregation]
             * Room has a Chairs => [Aggregation], Room has a Walls [Composition]
            */
            #endregion

            #region 6 Polymorphism
            /*
             * The same entity (method or operator or object) can perform different operations in different scenarios.
            */

            #region 1.Compile-Time [Static] Polymorphism

            #region 1-Method Overloading
            /*
             * Multiple methods in the same class can have the same name but different numbers, types, and order of parameters.
            
             * Overloaded methods may have the same or different return types, but they must have different parameters.
            */

            //Console.WriteLine($"Sum Overloading 1 => {Sum(1, 2)}");
            //Console.WriteLine($"Sum Overloading 2 => {Sum(1, 2, 3)}");
            //Console.WriteLine($"Sum Overloading 3 => {Sum(3.5, 6)}");
            //Console.WriteLine($"Sum Overloading 4 => {Sum(7, 4.3)}");
            //Console.WriteLine($"Sum Overloading 5 => {Sum(1, 2, 3, 4.2f)}");
            //Console.WriteLine("---------------------------");

            //Console.WriteLine($"WriteLine Overloading (String) => {"Abdalrhman"}");
            //Console.WriteLine($"WriteLine Overloading (char) => {'A'}");
            //Console.WriteLine($"WriteLine Overloading (int) => {10}");
            //Console.WriteLine($"WriteLine Overloading (float) => {10.6F}");
            //Console.WriteLine($"WriteLine Overloading (double) => {10.6d}");
            //Console.WriteLine($"WriteLine Overloading (bool) => {true}");
            #endregion

            #region 2-Constructor Overloading

            #endregion

            #region 3-Operator Overloading

            #endregion

            #endregion


            #region 2.Run-Time [Dynamic] Polymorphism

            #region 1-Method Overriding
            /*
             * During inheritance, if the same method is present in both the superclass and the subclass. 
               Then, the method in the subclass overrides the same method in the superclass.
             
             * The same method will perform one operation in the superclass and another operation in the subclass.
             
             * A method in derived class overrides the method in base class if the method in derived class has 
               (the same name, same return type and same parameters) as that of the base class.
                         
             * We can achieve method overriding in two Ways :
                
                * 1. [virtual] and [override] keywords 
                    * [virtual] - allows the method to be overridden by the derived class.
                    * [override] - indicates the method is overriding the method from the base class.
                    
                * 2. [new] keyWord  
                    * [new] => new version of the method in the base class.
            */

            //TypeD typeD = new TypeD(3);
            //typeD.A = 10;
            //typeD.WhereAmI();
            //typeD.Print();

            //Console.WriteLine("----------------------");

            //TypeC typeC = new TypeC(4, 8);
            //typeC.A = 20;
            //typeC.B = 30;   
            //typeC.WhereAmI();
            //typeC.Print();
            #endregion

            #endregion

            #endregion
        }
    }
}
